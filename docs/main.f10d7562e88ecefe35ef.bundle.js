(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{328:function(module,exports,__webpack_require__){__webpack_require__(329),__webpack_require__(523),module.exports=__webpack_require__(524)},348:function(module,exports){},524:function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__),function(module){var _storybook_react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(327);module._StorybookPreserveDecorators=!0,Object(_storybook_react__WEBPACK_IMPORTED_MODULE_0__.configure)([__webpack_require__(708)],module)}.call(this,__webpack_require__(525)(module))},708:function(module,exports,__webpack_require__){var map={"./show/index.stories.js":718,"./switch/index.stories.js":717};function webpackContext(req){var id=webpackContextResolve(req);return __webpack_require__(id)}function webpackContextResolve(req){if(!__webpack_require__.o(map,req)){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}return map[req]}webpackContext.keys=function webpackContextKeys(){return Object.keys(map)},webpackContext.resolve=webpackContextResolve,module.exports=webpackContext,webpackContext.id=708},717:function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__);var react=__webpack_require__(0),react_default=__webpack_require__.n(react),Switch=(__webpack_require__(26),__webpack_require__(61),__webpack_require__(111),__webpack_require__(27),function(_ref){var children=_ref.children,test=_ref.test,result=null,defaultCase=null;return react_default.a.Children.forEach(children,(function(child){child.type===Switch.Case&&test===child.props.test&&(result=child),child.type===Switch.Default&&(defaultCase=child)})),result||defaultCase});Switch.Case=Switch.Default=function(_ref2){var match=_ref2.match,children=_ref2.children;return match||children};var src_switch=Switch,classCallCheck=__webpack_require__(127),createClass=__webpack_require__(128),possibleConstructorReturn=__webpack_require__(131),getPrototypeOf=__webpack_require__(129),assertThisInitialized=__webpack_require__(77),inherits=__webpack_require__(132),defineProperty=__webpack_require__(130),SwitchExample_ref=react_default.a.createElement(src_switch.Case,{test:1,match:"主页"}),_ref2=react_default.a.createElement(src_switch.Case,{test:2,match:"新闻"}),_ref3=react_default.a.createElement(src_switch.Case,{test:3,match:"个人中心"}),_ref4=react_default.a.createElement(src_switch.Default,{match:"主页"}),SwitchExample_SwitchExample=function(_React$Component){function SwitchExample(props){var _this;return Object(classCallCheck.a)(this,SwitchExample),_this=Object(possibleConstructorReturn.a)(this,Object(getPrototypeOf.a)(SwitchExample).call(this,props)),Object(defineProperty.a)(Object(assertThisInitialized.a)(_this),"handleClick",(function(tab){_this.setState({tab:tab})})),_this.state={tab:1},_this}return Object(inherits.a)(SwitchExample,_React$Component),Object(createClass.a)(SwitchExample,[{key:"render",value:function render(){var _this2=this,tab=this.state.tab;return react_default.a.createElement("div",null,react_default.a.createElement("div",null,react_default.a.createElement("button",{onClick:function onClick(){return _this2.handleClick(1)}},"主页"),react_default.a.createElement("button",{onClick:function onClick(){return _this2.handleClick(2)}},"新闻"),react_default.a.createElement("button",{onClick:function onClick(){return _this2.handleClick(3)}},"用户中心"),react_default.a.createElement("button",{onClick:function onClick(){return _this2.handleClick(404)}},"错误页面")),react_default.a.createElement(src_switch,{test:tab},SwitchExample_ref,_ref2,_ref3,_ref4))}}]),SwitchExample}(react_default.a.Component);SwitchExample_SwitchExample.displayName="SwitchExample",SwitchExample_SwitchExample.__docgenInfo={description:"",methods:[{name:"handleClick",docblock:null,modifiers:[],params:[{name:"tab",type:null}],returns:null}],displayName:"SwitchExample"};var switch_SwitchExample=SwitchExample_SwitchExample;"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/switch/SwitchExample/index.js"]={name:"SwitchExample",docgenInfo:SwitchExample_SwitchExample.__docgenInfo,path:"src/switch/SwitchExample/index.js"}),__webpack_require__.d(__webpack_exports__,"SwitchMatch",(function(){return SwitchMatch}));__webpack_require__(126).withSource;var addSourceDecorator=__webpack_require__(126).addSource,index_stories_ref=(__webpack_exports__.default={parameters:{storySource:{source:'import React from "react";\nimport Switch from "./index";\nimport SwitchExample from "./SwitchExample";\n\nexport default {\n\ttitle: "Switch",\n\tcomponent: Switch,\n};\n\nexport const SwitchMatch = () => (\n\t<div>\n\t\t<h1>示例</h1>\n\t\t<div style={{border: "1px solid #eee", padding: "10px"}}>\n\t\t\t<SwitchExample/>\n\t\t</div>\n\n\t\t<h2>概述</h2>\n\t\t<p>\n\t\t\t在 React 中，还有一个常用的模式就是 Map，根据对应的值，显示对应的组件，比如前面例子中的 Tabs。我们通常会这么实现这种模式：\n\t\t</p>\n\t\t<pre>\n\t\t\t{\'const map = {\\n\' +\n\t\t\t\'\t1:"主页",\\n\' +\n\t\t\t\'\t2:"新闻",\\n\' +\n\t\t\t\'\t3:"个人中心"\\n\' +\n            \'}\'}\n\t\t</pre>\n\t\t<p>然后在 render 中：</p>\n\t\t<pre>\n\t\t\t{\'{map[tab]}\'}\n\t\t</pre>\n\t\t<p>这么实现有两个问题：</p>\n\t\t<ul>\n\t\t\t<li>丢失了细节，我们无法直接从 map[tab] 看出来，到底渲染了什么组件</li>\n\t\t\t<li>如果 tab 是错误的值，这里没有对错误数据的处理，如果要处理错误，也需要其他的逻辑</li>\n\t\t</ul>\n\t\t<h2>解决以上问题：</h2>\n\t\t<pre>\n\t\t\t{\'<Switch test={tab}>\\n\' +\n            \'    <Switch.Case test={1} match={"主页"}/>\\n\' +\n            \'    <Switch.Case test={2} match={"新闻"}/>\\n\' +\n            \'    <Switch.Case test={3} match={"个人中心"}/>\\n\' +\n            \'    <Switch.Default match={"主页"}/>\\n\' +\n            \'</Switch>\'}\n\t\t</pre>\n\t\t<p>爽多了！！！</p>\n\t</div>\n);\n\n',locationsMap:{"switch--switch-match":{startLoc:{col:27,line:10},endLoc:{col:1,line:48},startBody:{col:27,line:10},endBody:{col:1,line:48}}}}},title:"Switch",component:src_switch},react_default.a.createElement("h1",null,"示例")),index_stories_ref2=react_default.a.createElement(switch_SwitchExample,null),index_stories_ref3=react_default.a.createElement("h2",null,"概述"),index_stories_ref4=react_default.a.createElement("p",null,"在 React 中，还有一个常用的模式就是 Map，根据对应的值，显示对应的组件，比如前面例子中的 Tabs。我们通常会这么实现这种模式："),_ref5=react_default.a.createElement("pre",null,'const map = {\n\t1:"主页",\n\t2:"新闻",\n\t3:"个人中心"\n}'),_ref6=react_default.a.createElement("p",null,"然后在 render 中："),_ref7=react_default.a.createElement("pre",null,"{map[tab]}"),_ref8=react_default.a.createElement("p",null,"这么实现有两个问题："),_ref9=react_default.a.createElement("ul",null,react_default.a.createElement("li",null,"丢失了细节，我们无法直接从 map[tab] 看出来，到底渲染了什么组件"),react_default.a.createElement("li",null,"如果 tab 是错误的值，这里没有对错误数据的处理，如果要处理错误，也需要其他的逻辑")),_ref10=react_default.a.createElement("h2",null,"解决以上问题："),_ref11=react_default.a.createElement("pre",null,'<Switch test={tab}>\n    <Switch.Case test={1} match={"主页"}/>\n    <Switch.Case test={2} match={"新闻"}/>\n    <Switch.Case test={3} match={"个人中心"}/>\n    <Switch.Default match={"主页"}/>\n</Switch>'),_ref12=react_default.a.createElement("p",null,"爽多了！！！"),SwitchMatch=addSourceDecorator((function(){return react_default.a.createElement("div",null,index_stories_ref,react_default.a.createElement("div",{style:{border:"1px solid #eee",padding:"10px"}},index_stories_ref2),index_stories_ref3,index_stories_ref4,_ref5,_ref6,_ref7,_ref8,_ref9,_ref10,_ref11,_ref12)}),{__STORY__:'import React from "react";\nimport Switch from "./index";\nimport SwitchExample from "./SwitchExample";\n\nexport default {\n\ttitle: "Switch",\n\tcomponent: Switch,\n};\n\nexport const SwitchMatch = () => (\n\t<div>\n\t\t<h1>示例</h1>\n\t\t<div style={{border: "1px solid #eee", padding: "10px"}}>\n\t\t\t<SwitchExample/>\n\t\t</div>\n\n\t\t<h2>概述</h2>\n\t\t<p>\n\t\t\t在 React 中，还有一个常用的模式就是 Map，根据对应的值，显示对应的组件，比如前面例子中的 Tabs。我们通常会这么实现这种模式：\n\t\t</p>\n\t\t<pre>\n\t\t\t{\'const map = {\\n\' +\n\t\t\t\'\t1:"主页",\\n\' +\n\t\t\t\'\t2:"新闻",\\n\' +\n\t\t\t\'\t3:"个人中心"\\n\' +\n            \'}\'}\n\t\t</pre>\n\t\t<p>然后在 render 中：</p>\n\t\t<pre>\n\t\t\t{\'{map[tab]}\'}\n\t\t</pre>\n\t\t<p>这么实现有两个问题：</p>\n\t\t<ul>\n\t\t\t<li>丢失了细节，我们无法直接从 map[tab] 看出来，到底渲染了什么组件</li>\n\t\t\t<li>如果 tab 是错误的值，这里没有对错误数据的处理，如果要处理错误，也需要其他的逻辑</li>\n\t\t</ul>\n\t\t<h2>解决以上问题：</h2>\n\t\t<pre>\n\t\t\t{\'<Switch test={tab}>\\n\' +\n            \'    <Switch.Case test={1} match={"主页"}/>\\n\' +\n            \'    <Switch.Case test={2} match={"新闻"}/>\\n\' +\n            \'    <Switch.Case test={3} match={"个人中心"}/>\\n\' +\n            \'    <Switch.Default match={"主页"}/>\\n\' +\n            \'</Switch>\'}\n\t\t</pre>\n\t\t<p>爽多了！！！</p>\n\t</div>\n);\n\n',__ADDS_MAP__:{"switch--switch-match":{startLoc:{col:27,line:10},endLoc:{col:1,line:48},startBody:{col:27,line:10},endBody:{col:1,line:48}}},__MAIN_FILE_LOCATION__:"/index.stories.js",__MODULE_DEPENDENCIES__:[],__LOCAL_DEPENDENCIES__:{},__SOURCE_PREFIX__:"/Users/lyxxxx/Own/react-dl/src/switch",__IDS_TO_FRAMEWORKS__:{}})},718:function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__);var classCallCheck=__webpack_require__(127),createClass=__webpack_require__(128),possibleConstructorReturn=__webpack_require__(131),getPrototypeOf=__webpack_require__(129),assertThisInitialized=__webpack_require__(77),inherits=__webpack_require__(132),defineProperty=__webpack_require__(130),react=__webpack_require__(0),react_default=__webpack_require__.n(react),show=function(_ref){var test=_ref.test,children=_ref.children;return test?children:null};__webpack_require__.d(__webpack_exports__,"ShowToggle",(function(){return ShowToggle}));__webpack_require__(126).withSource;var addSourceDecorator=__webpack_require__(126).addSource,_ref=(__webpack_exports__.default={parameters:{storySource:{source:"import React from \"react\";\nimport Show from \"./index\";\n\nexport default {\n    title: \"Show\",\n    component: Show,\n};\n\nclass ShowExample extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            visible: true\n        };\n    }\n\n    handleClick = () => {\n        this.setState({\n            visible: !this.state.visible\n        })\n    }\n\n    render() {\n        const {visible} = this.state;\n        return <div>\n            <Show test={visible}>\n                <p>显示</p>\n            </Show>\n            <button onClick={this.handleClick}>\n                <Show test={visible}>\n                    隐藏\n                </Show>\n                <Show test={!visible}>\n                    显示\n                </Show>\n            </button>\n        </div>;\n    }\n}\n\nexport const ShowToggle = () => (<div>\n    <h1>例子</h1>\n    <div style={{border: '1px solid #eee', padding: '10px'}}>\n        <ShowExample/>\n    </div>\n    <h2>概述</h2>\n    <p>\n        在 React 开发中，我们常常需要根据条件去展示或者隐藏一个组件，正如前面的例子所示。\n    </p>\n    <p>\n        我们通常使用`三目运算符`或者`逻辑守卫`来达到这个效果。比如：\n    </p>\n    <code>\n        {'isShow: <p>显示</p> ? null'}\n    </code>\n    <p>或者：</p>\n    <code>\n        {'isShow && <p>显示</p>'}\n    </code>\n    <p>但是这存在一些问题：</p>\n    <ul>\n        <li>中间有一层逻辑转化。</li>\n        <li>当逻辑过分复杂的时候，嵌套太深。</li>\n    </ul>\n    <hr/>\n    <h2>逻辑转化</h2>\n    <p>React 是声明式的，然而在这一块，却成了命令式的，尽管三目运算符或者逻辑守卫已经够简单了，但是在阅读这种逻辑的时候，依旧要经过一层逻辑转化。对我而言，这是封装泄漏：</p>\n    <code>\n        {'isShow: <p>显示</p> ? null'}\n    </code>\n    <p>使用 Show 组件后：</p>\n    <pre>\n        {'<Show test={isShow}> \\n' +\n        '   <p>显示</p> \\n' +\n        '</Show>'}\n    </pre>\n    <p>将逻辑转化为了声明。</p>\n    <hr/>\n\n    <h2>复杂逻辑</h2>\n    <p>在逻辑很复杂的时候，这中间的逻辑更加恐怖。假设如下场景，一个页面有编辑态和详情态，编辑态根据是否有写权限有两种情况；详情态根据是否在线也有两种状态：</p>\n    <pre>\n        {'    isEdit?(\\n' +\n        '              <div>\\n' +\n        '                  {\\n' +\n        '                      hasWrite?(\\n' +\n        '                          <button>编辑</button>\\n' +\n        '                      ):(\\n' +\n        '                          <button>查看</button>\\n' +\n        '                      )\\n' +\n        '                  }\\n' +\n        '              </div>\\n' +\n        '          ):(\\n' +\n        '              <div>\\n' +\n        '                  {isOnline?(\\n' +\n        '                      <button>下线</button>\\n' +\n        '                  ):(\\n' +\n        '                      <button>上线</button>\\n' +\n        '                  )}\\n' +\n        '              </div>\\n' +\n        '          )\\n' +\n        '    )'}\n    </pre>\n    <p>使用 Show 之后：</p>\n    <pre>\n        {'' +\n        '\\n' +\n        '    isShow = (show) => ({children}) => <Show test={show} > {children} </Show>\\n' +\n        '\\n' +\n        '    const InEdit = isShow(isEdit)\\n' +\n        '    const InDetail = isShow(!isEdit)\\n' +\n        '    \\n' +\n        '    const HasWrite = isShow(hasWrite)\\n' +\n        '    const NotHasWrite= isShow(!hasWrite)\\n' +\n        '    \\n' +\n        '    const Online= isShow(online)\\n' +\n        '    const Offline= isShow(!online)\\n' +\n        '    \\n' +\n        '    return (\\n' +\n        '        <div>\\n' +\n        '            <InEdit>\\n' +\n        '                <HasWrite>\\n' +\n        '                    <button>编辑</button>\\n' +\n        '                </HasWrite>\\n' +\n        '                <NotHasWrite>\\n' +\n        '                    <button>查看</button>\\n' +\n        '                </NotHasWrite>\\n' +\n        '            </InEdit>\\n' +\n        '            <InDetail>\\n' +\n        '                <Online>\\n' +\n        '                    <button>下线</button>\\n' +\n        '                </Online>\\n' +\n        '                <Offline>\\n' +\n        '                    <button>下线</button>\\n' +\n        '                </Offline>\\n' +\n        '            </InDetail>\\n' +\n        '         </div>\\n' +\n        '    )\\n'}\n    </pre>\n\n    <p>虽然看过去代码量多了，但是在大型项目中，代码的可维护性比起代码量来说，远远来的重要。</p>\n\n</div>)\n",locationsMap:{"show--show-toggle":{startLoc:{col:26,line:41},endLoc:{col:7,line:143},startBody:{col:26,line:41},endBody:{col:7,line:143}}}}},title:"Show",component:show},react_default.a.createElement("p",null,"显示")),index_stories_ShowExample=function(_React$Component){function ShowExample(props){var _this;return Object(classCallCheck.a)(this,ShowExample),_this=Object(possibleConstructorReturn.a)(this,Object(getPrototypeOf.a)(ShowExample).call(this,props)),Object(defineProperty.a)(Object(assertThisInitialized.a)(_this),"handleClick",(function(){_this.setState({visible:!_this.state.visible})})),_this.state={visible:!0},_this}return Object(inherits.a)(ShowExample,_React$Component),Object(createClass.a)(ShowExample,[{key:"render",value:function render(){var visible=this.state.visible;return react_default.a.createElement("div",null,react_default.a.createElement(show,{test:visible},_ref),react_default.a.createElement("button",{onClick:this.handleClick},react_default.a.createElement(show,{test:visible},"隐藏"),react_default.a.createElement(show,{test:!visible},"显示")))}}]),ShowExample}(react_default.a.Component);index_stories_ShowExample.displayName="ShowExample";var _ref2=react_default.a.createElement("h1",null,"例子"),_ref3=react_default.a.createElement(index_stories_ShowExample,null),_ref4=react_default.a.createElement("h2",null,"概述"),_ref5=react_default.a.createElement("p",null,"在 React 开发中，我们常常需要根据条件去展示或者隐藏一个组件，正如前面的例子所示。"),_ref6=react_default.a.createElement("p",null,"我们通常使用`三目运算符`或者`逻辑守卫`来达到这个效果。比如："),_ref7=react_default.a.createElement("code",null,"isShow: <p>显示</p> ? null"),_ref8=react_default.a.createElement("p",null,"或者："),_ref9=react_default.a.createElement("code",null,"isShow && <p>显示</p>"),_ref10=react_default.a.createElement("p",null,"但是这存在一些问题："),_ref11=react_default.a.createElement("ul",null,react_default.a.createElement("li",null,"中间有一层逻辑转化。"),react_default.a.createElement("li",null,"当逻辑过分复杂的时候，嵌套太深。")),_ref12=react_default.a.createElement("hr",null),_ref13=react_default.a.createElement("h2",null,"逻辑转化"),_ref14=react_default.a.createElement("p",null,"React 是声明式的，然而在这一块，却成了命令式的，尽管三目运算符或者逻辑守卫已经够简单了，但是在阅读这种逻辑的时候，依旧要经过一层逻辑转化。对我而言，这是封装泄漏："),_ref15=react_default.a.createElement("code",null,"isShow: <p>显示</p> ? null"),_ref16=react_default.a.createElement("p",null,"使用 Show 组件后："),_ref17=react_default.a.createElement("pre",null,"<Show test={isShow}> \n   <p>显示</p> \n</Show>"),_ref18=react_default.a.createElement("p",null,"将逻辑转化为了声明。"),_ref19=react_default.a.createElement("hr",null),_ref20=react_default.a.createElement("h2",null,"复杂逻辑"),_ref21=react_default.a.createElement("p",null,"在逻辑很复杂的时候，这中间的逻辑更加恐怖。假设如下场景，一个页面有编辑态和详情态，编辑态根据是否有写权限有两种情况；详情态根据是否在线也有两种状态："),_ref22=react_default.a.createElement("pre",null,"    isEdit?(\n              <div>\n                  {\n                      hasWrite?(\n                          <button>编辑</button>\n                      ):(\n                          <button>查看</button>\n                      )\n                  }\n              </div>\n          ):(\n              <div>\n                  {isOnline?(\n                      <button>下线</button>\n                  ):(\n                      <button>上线</button>\n                  )}\n              </div>\n          )\n    )"),_ref23=react_default.a.createElement("p",null,"使用 Show 之后："),_ref24=react_default.a.createElement("pre",null,"\n    isShow = (show) => ({children}) => <Show test={show} > {children} </Show>\n\n    const InEdit = isShow(isEdit)\n    const InDetail = isShow(!isEdit)\n    \n    const HasWrite = isShow(hasWrite)\n    const NotHasWrite= isShow(!hasWrite)\n    \n    const Online= isShow(online)\n    const Offline= isShow(!online)\n    \n    return (\n        <div>\n            <InEdit>\n                <HasWrite>\n                    <button>编辑</button>\n                </HasWrite>\n                <NotHasWrite>\n                    <button>查看</button>\n                </NotHasWrite>\n            </InEdit>\n            <InDetail>\n                <Online>\n                    <button>下线</button>\n                </Online>\n                <Offline>\n                    <button>下线</button>\n                </Offline>\n            </InDetail>\n         </div>\n    )\n"),_ref25=react_default.a.createElement("p",null,"虽然看过去代码量多了，但是在大型项目中，代码的可维护性比起代码量来说，远远来的重要。"),ShowToggle=addSourceDecorator((function(){return react_default.a.createElement("div",null,_ref2,react_default.a.createElement("div",{style:{border:"1px solid #eee",padding:"10px"}},_ref3),_ref4,_ref5,_ref6,_ref7,_ref8,_ref9,_ref10,_ref11,_ref12,_ref13,_ref14,_ref15,_ref16,_ref17,_ref18,_ref19,_ref20,_ref21,_ref22,_ref23,_ref24,_ref25)}),{__STORY__:"import React from \"react\";\nimport Show from \"./index\";\n\nexport default {\n    title: \"Show\",\n    component: Show,\n};\n\nclass ShowExample extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            visible: true\n        };\n    }\n\n    handleClick = () => {\n        this.setState({\n            visible: !this.state.visible\n        })\n    }\n\n    render() {\n        const {visible} = this.state;\n        return <div>\n            <Show test={visible}>\n                <p>显示</p>\n            </Show>\n            <button onClick={this.handleClick}>\n                <Show test={visible}>\n                    隐藏\n                </Show>\n                <Show test={!visible}>\n                    显示\n                </Show>\n            </button>\n        </div>;\n    }\n}\n\nexport const ShowToggle = () => (<div>\n    <h1>例子</h1>\n    <div style={{border: '1px solid #eee', padding: '10px'}}>\n        <ShowExample/>\n    </div>\n    <h2>概述</h2>\n    <p>\n        在 React 开发中，我们常常需要根据条件去展示或者隐藏一个组件，正如前面的例子所示。\n    </p>\n    <p>\n        我们通常使用`三目运算符`或者`逻辑守卫`来达到这个效果。比如：\n    </p>\n    <code>\n        {'isShow: <p>显示</p> ? null'}\n    </code>\n    <p>或者：</p>\n    <code>\n        {'isShow && <p>显示</p>'}\n    </code>\n    <p>但是这存在一些问题：</p>\n    <ul>\n        <li>中间有一层逻辑转化。</li>\n        <li>当逻辑过分复杂的时候，嵌套太深。</li>\n    </ul>\n    <hr/>\n    <h2>逻辑转化</h2>\n    <p>React 是声明式的，然而在这一块，却成了命令式的，尽管三目运算符或者逻辑守卫已经够简单了，但是在阅读这种逻辑的时候，依旧要经过一层逻辑转化。对我而言，这是封装泄漏：</p>\n    <code>\n        {'isShow: <p>显示</p> ? null'}\n    </code>\n    <p>使用 Show 组件后：</p>\n    <pre>\n        {'<Show test={isShow}> \\n' +\n        '   <p>显示</p> \\n' +\n        '</Show>'}\n    </pre>\n    <p>将逻辑转化为了声明。</p>\n    <hr/>\n\n    <h2>复杂逻辑</h2>\n    <p>在逻辑很复杂的时候，这中间的逻辑更加恐怖。假设如下场景，一个页面有编辑态和详情态，编辑态根据是否有写权限有两种情况；详情态根据是否在线也有两种状态：</p>\n    <pre>\n        {'    isEdit?(\\n' +\n        '              <div>\\n' +\n        '                  {\\n' +\n        '                      hasWrite?(\\n' +\n        '                          <button>编辑</button>\\n' +\n        '                      ):(\\n' +\n        '                          <button>查看</button>\\n' +\n        '                      )\\n' +\n        '                  }\\n' +\n        '              </div>\\n' +\n        '          ):(\\n' +\n        '              <div>\\n' +\n        '                  {isOnline?(\\n' +\n        '                      <button>下线</button>\\n' +\n        '                  ):(\\n' +\n        '                      <button>上线</button>\\n' +\n        '                  )}\\n' +\n        '              </div>\\n' +\n        '          )\\n' +\n        '    )'}\n    </pre>\n    <p>使用 Show 之后：</p>\n    <pre>\n        {'' +\n        '\\n' +\n        '    isShow = (show) => ({children}) => <Show test={show} > {children} </Show>\\n' +\n        '\\n' +\n        '    const InEdit = isShow(isEdit)\\n' +\n        '    const InDetail = isShow(!isEdit)\\n' +\n        '    \\n' +\n        '    const HasWrite = isShow(hasWrite)\\n' +\n        '    const NotHasWrite= isShow(!hasWrite)\\n' +\n        '    \\n' +\n        '    const Online= isShow(online)\\n' +\n        '    const Offline= isShow(!online)\\n' +\n        '    \\n' +\n        '    return (\\n' +\n        '        <div>\\n' +\n        '            <InEdit>\\n' +\n        '                <HasWrite>\\n' +\n        '                    <button>编辑</button>\\n' +\n        '                </HasWrite>\\n' +\n        '                <NotHasWrite>\\n' +\n        '                    <button>查看</button>\\n' +\n        '                </NotHasWrite>\\n' +\n        '            </InEdit>\\n' +\n        '            <InDetail>\\n' +\n        '                <Online>\\n' +\n        '                    <button>下线</button>\\n' +\n        '                </Online>\\n' +\n        '                <Offline>\\n' +\n        '                    <button>下线</button>\\n' +\n        '                </Offline>\\n' +\n        '            </InDetail>\\n' +\n        '         </div>\\n' +\n        '    )\\n'}\n    </pre>\n\n    <p>虽然看过去代码量多了，但是在大型项目中，代码的可维护性比起代码量来说，远远来的重要。</p>\n\n</div>)\n",__ADDS_MAP__:{"show--show-toggle":{startLoc:{col:26,line:41},endLoc:{col:7,line:143},startBody:{col:26,line:41},endBody:{col:7,line:143}}},__MAIN_FILE_LOCATION__:"/index.stories.js",__MODULE_DEPENDENCIES__:[],__LOCAL_DEPENDENCIES__:{},__SOURCE_PREFIX__:"/Users/lyxxxx/Own/react-dl/src/show",__IDS_TO_FRAMEWORKS__:{}})}},[[328,1,2]]]);
//# sourceMappingURL=main.f10d7562e88ecefe35ef.bundle.js.map